#!/usr/bin/env bash
# vim: set filetype=bash:

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

source "$SCRIPT_DIR/_lib"

PROJECT_DIR="$(dirname "$SCRIPT_DIR")"
SERVER_DIR="$PROJECT_DIR/server"
CONFIG_FILE="$PROJECT_DIR/config/mods.json"
WORKSHOP_ID=221100
DAYZ_MOD_P_DRIVE="${DAYZ_MOD_P_DRIVE:-/mnt/Store/Projects/Mine/Dayz_P_Drive}"

STEAMCMD_CMD=""

TEMPLATE_USAGE="""
DayZ Mod Manager

Usage: $0 [COMMAND] [ARGS]

Commands:
    new NAME                        - Create new local mod (registers in mods.json and serverDZ.cfg)
    build NAME                      - Build local mod into PBO (requires Docker)
    workbench NAME                  - Launch Workbench for mod (experimental; requires Steam account)
    setup_workdrive PATH            - Setup symlinks for Workbench (Linux/WSL only; set DAYZ_MOD_P_DRIVE env var)
    status                          - Show configured and installed mods
    client-check                    - Verify configured mods in local Steam Workshop cache
    search QUERY                    - Search for mods on Steam Workshop
    enable ID NAME                  - Enable a mod (add to mods.json)
    disable NAME                    - Disable a mod (remove from mods.json)
    remove NAME_OR_ID               - Remove mod (from mods.json and filesystem)
    install                         - Download all enabled mods
    update                          - Update all enabled mods
    help                            - Show this help message

Examples:
    $0 new mymod
    $0 build mymod
    $0 workbench mymod
    $0 setup_workdrive /mnt/dayz-workdrive
    $0 status
    $0 search expansion
    $0 enable 1559212036 '@cf'
    $0 install
    $0 update

"""

get_steamcmd() {
    if command -v steamcmd &> /dev/null; then
        STEAMCMD_CMD="steamcmd"
        return 0
    fi

    if [ -f "$HOME/.local/share/steamcmd/steamcmd.sh" ]; then
        STEAMCMD_CMD="$HOME/.local/share/steamcmd/steamcmd.sh"
        return 0
    fi

    if [ -f "$HOME/.steam/steamcmd/steamcmd.sh" ]; then
        STEAMCMD_CMD="$HOME/.steam/steamcmd/steamcmd.sh"
        return 0
    fi

    return 1
}

run_steamcmd() {
    if [ -z "$STEAMCMD_CMD" ]; then
        echo "[!] SteamCMD not found"
        return 1
    fi
    "$STEAMCMD_CMD" "$@"
    return $?
}



print_usage() {
    echo "$TEMPLATE_USAGE"
}

check_server_exists() {
    if [ ! -f "$SERVER_DIR/DayZServer" ]; then
        echo "[!] Error: DayZ Server not installed at $SERVER_DIR"
        echo "[*] Run: $SCRIPT_DIR/install"
        exit 1
    fi
}

check_config_exists() {
    if [ ! -f "$CONFIG_FILE" ]; then
        echo "[!] No mods.json found at $CONFIG_FILE"
        echo "[*] Creating template..."
        create_mod_config
        return 1
    fi
    return 0
}

create_mod_config() {
    local config_object

    jq -n '{mods: []}' > "$CONFIG_FILE" 2>/dev/null

    echo "[+] Created $CONFIG_FILE"
    echo "[*] Edit this file to enable or disable mods as needed"
}

status_mods() {
    check_config_exists || return 0

    echo "========================================"
    echo "Configured Mods"
    echo "========================================"
    echo ""

    local mod_count=$(jq '.mods | length' "$CONFIG_FILE")

    if [ "$mod_count" -eq 0 ]; then
        echo "[*] No mods configured"
        return 0
    fi

    jq -r '.mods | to_entries | .[] | "\(.key + 1). \(.value.name) (ID: \(.value.id))"' "$CONFIG_FILE" | while read line; do
        echo "$line"
        mod_name=$(echo "$line" | grep -oP '@\S+')
        if [ -d "$PROJECT_DIR/mods/$mod_name" ]; then
            local size=$(du -sh "$PROJECT_DIR/mods/$mod_name" 2>/dev/null | cut -f1)
            echo "   Status: [INSTALLED] ($size)"
        else
            echo "   Status: [NOT INSTALLED]"
        fi
    done

    echo ""
    echo "Total: $mod_count mod(s)"
}

scrape_workshop_page() {
    local search_url
    local html
    local query

    query="$1"
    search_url="https://steamcommunity.com/workshop/browse/?appid=$WORKSHOP_ID&searchtext=$(echo "$query" | sed 's/ /%20/g')&numperpage=50"
    html=$(curl -s -A "Mozilla/5.0" "$search_url" 2>/dev/null)

    if [ -z "$html" ]; then
        echo "[!] Failed to fetch search results"
        echo "[*] Visit Steam Workshop: $search_url"
        return 1
    fi

    echo "$html"
}

search_mods() {
    local query="$@"

    if [ -z "$query" ]; then
        echo "[!] Usage: $0 search QUERY"
        echo "[!] Example: $0 search expansion"
        exit 1
    fi

    check_curl
    check_jq

    echo "Searching: $query"
    echo "[*] Querying Steam Workshop..."
    echo ""

    local mod_ids=$(echo "$(scrape_workshop_page "$query")" | grep -oP '/sharedfiles/filedetails/\?id=\K\d+' | head -10 | uniq)

    if [ -z "$mod_ids" ]; then
        echo "[*] No mods found for '$query'"
        echo ""
        echo "Visit Steam Workshop:"
        echo "  $search_url"
        echo ""
        return 0
    fi

    local api_url="https://api.steampowered.com/ISteamRemoteStorage/GetPublishedFileDetails/v1/"
    local post_data="itemcount=$(echo "$mod_ids" | wc -l)"
    local index=0

    for mod_id in $mod_ids; do
        post_data="$post_data&publishedfileids[$index]=$mod_id"
        ((index++))
    done

    local response=$(curl -s -X POST -d "$post_data" "$api_url" 2>/dev/null)

    if [ -z "$response" ]; then
        echo "[!] Failed to fetch mod details from API"
        return 1
    fi

    local mod_count=$(echo "$response" | jq '.response.publishedfiledetails | length' 2>/dev/null)

    if [ -z "$mod_count" ] || [ "$mod_count" -eq 0 ]; then
        echo "[*] No mod details available"
        return 0
    fi


    echo "Found mods:"
    echo ""

    template="""
    Title: {title}
    ID: {id}
    Subscriptions: {subs}
    """

    echo "$response" | jq -r '.response.publishedfiledetails[] |
        select(.result == 1 and .publishedfileid != null and .publishedfileid != "") |
        " [\(.publishedfileid)] \(.title|gsub("-"; " ")|gsub("  "; " "))\n" +
        "   created: \(.time_created | strftime("%Y-%m-%d %H:%M:%S"))\n" +
        "   updated: \(.time_updated | strftime("%Y-%m-%d %H:%M:%S"))\n" +
        " \n"
    '
}



enable_mod() {
    local mod_id=$1
    local mod_name=$2

    if [ -z "$mod_id" ] || [ -z "$mod_name" ]; then
        echo "[!] Usage: $0 enable MOD_ID MOD_NAME"
        echo "[!] Example: $0 enable 1559212036 '@cf'"
        exit 1
    fi

    check_config_exists || return 0

    if jq --arg id "$mod_id" '.mods[] | select(.id == ($id | tonumber))' "$CONFIG_FILE" | grep -q .; then
        echo "[!] Mod ID $mod_id already exists"
        exit 1
    fi

    local temp_file=$(mktemp)
    jq --arg id "$mod_id" --arg name "$mod_name" \
        '.mods += [{"id": ($id | tonumber), "name": $name, "title": $name}]' \
        "$CONFIG_FILE" > "$temp_file"

    mv "$temp_file" "$CONFIG_FILE"

    echo "[+] Enabled mod: $mod_name (ID: $mod_id)"
}

disable_mod() {
    local mod_name=$1

    if [ -z "$mod_name" ]; then
        echo "[!] Usage: $0 disable MOD_NAME"
        exit 1
    fi

    check_config_exists || return 0

    if ! jq --arg name "$mod_name" '.mods[] | select(.name == $name)' "$CONFIG_FILE" | grep -q .; then
        echo "[!] Mod not found: $mod_name"
        exit 1
    fi

    local temp_file=$(mktemp)
    jq --arg name "$mod_name" \
        '.mods |= map(select(.name != $name))' \
        "$CONFIG_FILE" > "$temp_file"

    mv "$temp_file" "$CONFIG_FILE"

    echo "[+] Disabled mod: $mod_name"
}

install_mods() {
    check_jq
    check_server_exists
    check_config_exists || return 0

    local mod_count=$(jq '.mods | length' "$CONFIG_FILE")

    if [ "$mod_count" -eq 0 ]; then
        echo "[*] No mods configured"
        return 0
    fi

    echo "[*] Installing $mod_count mod(s)..."
    echo ""

    read -p "Enter Steam username: " steam_user
    read -sp "Enter Steam password: " steam_pass
    echo ""

    local steamcmd_args=(
        "+@NoPromptForPassword 1"
        "+force_install_dir $SERVER_DIR"
        "+login $steam_user $steam_pass"
    )

    while IFS=' ' read -r mod_id mod_name; do
        steamcmd_args+=("+workshop_download_item $WORKSHOP_ID $mod_id validate")
        echo "[*] Downloading: $mod_name (ID: $mod_id)"
    done < <(jq -r '.mods[] | "\(.id) \(.name)"' "$CONFIG_FILE")

    steamcmd_args+=("+quit")

    echo ""

    if ! get_steamcmd; then
        echo "[!] SteamCMD not found"
        return 1
    fi

    if ! run_steamcmd "${steamcmd_args[@]}"; then
        echo "[!] Failed to download mods"
        return 1
    fi

    process_mods
}

update_mods() {
    check_jq
    check_server_exists
    check_config_exists || return 0

    local mod_count=$(jq '.mods | length' "$CONFIG_FILE")

    if [ "$mod_count" -eq 0 ]; then
        echo "[*] No mods to update"
        return 0
    fi

    echo "[*] Updating $mod_count mod(s)..."
    echo ""

    read -p "Enter Steam username: " steam_user
    read -sp "Enter Steam password: " steam_pass
    echo ""

    local steamcmd_args=(
        "+@NoPromptForPassword 1"
        "+force_install_dir $SERVER_DIR"
        "+login $steam_user $steam_pass"
    )

    while IFS= read -r mod_id; do
        steamcmd_args+=("+workshop_download_item $WORKSHOP_ID $mod_id validate")
    done < <(jq -r '.mods[] | .id' "$CONFIG_FILE")

    steamcmd_args+=("+quit")

    if ! get_steamcmd; then
        echo "[!] SteamCMD not found"
        return 1
    fi

    if ! run_steamcmd "${steamcmd_args[@]}"; then
        echo "[!] Failed to update mods"
        return 1
    fi

    process_mods
}

process_mods() {
    echo ""
    echo "[*] Processing mods..."

    local mod_count=0

    while IFS=' ' read -r mod_id mod_name; do
        local mod_source="$SERVER_DIR/steamapps/workshop/content/$WORKSHOP_ID/$mod_id"
        local mod_target="$PROJECT_DIR/mods/$mod_name"

        if [ ! -d "$mod_source" ]; then
            echo "[!] Mod source not found: $mod_source"
            continue
        fi

        echo "[*] Processing $mod_name..."

        rm -rf "$mod_target"
        mkdir -p "$mod_target"
        cp -r "$mod_source"/* "$mod_target/" 2>/dev/null || true

        find "$mod_target" -depth -execdir bash -c 'mv "$0" "${0,,}"' {} \; 2>/dev/null || true

        if find "$mod_target" -name "*.bikey" | grep -q .; then
            mkdir -p "$PROJECT_DIR/keys"
            find "$mod_target" -name "*.bikey" -exec cp {} "$PROJECT_DIR/keys/" \;
            echo "    [+] Copied signing keys"
        fi

        ((mod_count++))
    done < <(jq -r '.mods[] | "\(.id) \(.name)"' "$CONFIG_FILE")

    echo "[+] Processed $mod_count mod(s)"
    echo ""
    echo "Mods are ready in: $PROJECT_DIR/mods"
}

new_mod() {
    local mod_name
    local mod_prefix
    local mod_dir
    local mod_name_formatted
    local template_token

    mod_name=$1
    template_token="ModTemplate"

    if [ -z "$mod_name" ]; then
        echo "[!] Usage: $0 new MOD_NAME"
        echo "[!] Example: $0 new mymod"
        exit 1
    fi


    mod_dir="$PROJECT_DIR/pkgs/$mod_name"

    if [ -d "$mod_dir" ]; then
        echo "[!] Error: Mod already exists at $mod_dir"
        exit 1
    fi

    echo "[*] Creating new mod: $mod_name"

    if ! git clone --depth 1 https://github.com/InclementDab/DayZ-Mod-Template.git "$mod_dir"; then
        echo "[!] Error: Failed to clone template repository"
        exit 1
    fi

    rm "$mod_dir/Init.ps1" "$mod_dir/.git" "$mod_dir/SetupWorkdrive.bat" "$mod_dir/LaunchWorkbench.bat"


    mod_prefix="${mod_name//[[:space:]]/}"
    if [ -z "$mod_prefix" ]; then
        mod_prefix="ModName"
    fi
    mod_name_formatted="@$mod_prefix"

    echo "[*] Creating script folders..."

    mkdir -p "$mod_dir/$template_token/Scripts/1_Core/$mod_prefix"
    mkdir -p "$mod_dir/$template_token/Scripts/2_GameLib/$mod_prefix"
    mkdir -p "$mod_dir/$template_token/Scripts/3_Game/$mod_prefix"
    mkdir -p "$mod_dir/$template_token/Scripts/4_World/$mod_prefix"
    mkdir -p "$mod_dir/$template_token/Scripts/5_Mission/$mod_prefix"

    echo "[*] Adding guides..."
    echo "# Core" > "$mod_dir/$template_token/Scripts/1_Core/$mod_prefix/README.md"
    echo "# GameLib" > "$mod_dir/$template_token/Scripts/2_GameLib/$mod_prefix/README.md"
    echo "# Game" > "$mod_dir/$template_token/Scripts/3_Game/$mod_prefix/README.md"
    echo "# World" > "$mod_dir/$template_token/Scripts/4_World/$mod_prefix/README.md"
    echo "# Mission" > "$mod_dir/$template_token/Scripts/5_Mission/$mod_prefix/README.md"

    mkdir -p "$mod_dir/Addons"
    mkdir -p "$mod_dir/Missions/Global"
    mkdir -p "$mod_dir/Profiles/Dev"
    mkdir -p "$mod_dir/Profiles/Global"

    echo "[*] Renaming ModTemplate folders..."
    find "$mod_dir" -type d -name "*$template_token*" | while read dir; do
        if [ "$template_token" != "$mod_prefix" ]; then
            new_dir="${dir//$template_token/$mod_prefix}"
            if [ "$dir" != "$new_dir" ]; then
                mv "$dir" "$new_dir"
            fi
        fi
    done

    echo "[*] Replacing tokens in files..."

    find "$mod_dir" -type f \( -name "*.cpp" -o -name "*.c" -o -name "*.gproj" -o -name "*.cfg" \) | while read file; do
        sed -i "s/$template_token/$mod_prefix/g" "$file"
    done

    echo "[+] Initialization complete!"

    mkdir -p "$PROJECT_DIR/mods"
    ln -sf "../pkgs/$mod_name" "$PROJECT_DIR/mods/$mod_name_formatted"

    echo "[+] Created mod: $mod_name"
    echo "[+] Location: $mod_dir"
    echo "[+] Symlink: $PROJECT_DIR/mods/$mod_name_formatted"
    echo ""

    # Add to mods.json for tracking
    echo "[*] Registering mod in config/mods.json..."
    local temp_file=$(mktemp)
    jq --arg id "0" --arg name "$mod_name_formatted" --arg title "$mod_name" \
        '.mods += [{"id": 0, "name": $name, "title": $title}]' \
        "$PROJECT_DIR/config/mods.json" > "$temp_file"
    mv "$temp_file" "$PROJECT_DIR/config/mods.json"
    echo "[+] Added to mods.json (ID: 0 for local dev)"

    # Add to serverDZ.cfg modDirs if not already present
    echo "[*] Registering mod in serverDZ.cfg..."
    if ! grep -q "mods/$mod_name_formatted" "$PROJECT_DIR/config/serverDZ.cfg"; then
        # Add comma to last entry if missing, then insert new mod
        sed -i "/modDirs\[\] = {/,/^};/{
            /^};/i\\    \"mods/$mod_name_formatted\",
            s/\"mods\/@de-ai\"$/\"mods\/@de-ai\",/
        }" "$PROJECT_DIR/config/serverDZ.cfg"
        echo "[+] Added to serverDZ.cfg modDirs"
    else
        echo "[*] Already in serverDZ.cfg modDirs"
    fi

    echo ""
    echo "Next steps:"
    echo "  1. Read the modding guide: docs/modding.md"
    echo "  2. Edit $mod_dir/mod.cpp"
    echo "  3. Add scripts to $mod_dir/Scripts/"
    echo "  4. Configure as needed in $mod_dir/config/"
    echo "  5. Start server: ./cmd/server start"
}

# We can only setup a workdrive for one mod at a time.
setup_workdrive() {
    local mod_name

    mod_name=$1
    drive_path="${2:-$DAYZ_MOD_P_DRIVE}"
    
    if [ -z "$drive_path" ]; then
        echo "[!] Error: DAYZ_MOD_P_DRIVE environment variable is required"
        echo "[!] Set it and try again:"
        echo "    export DAYZ_MOD_P_DRIVE=/path/to/workdrive"
        echo "    ./cmd/mods setup_workdrive $mod_name"
        return 1
    fi
    
    echo "[*] Setting up Workdrive symlinks..."
    echo "[*] Drive path: $drive_path"

    local mod_folder_name
    local junction_path

    for dir in "$PROJECT_DIR/pkgs/$mod_name/"*; do
        if [ -d "$dir/Workbench" ] && [ -f "$dir/Workbench/dayz.gproj" ]; then
            mod_folder_name=$(basename "$dir")
            junction_path="$drive_path/$mod_folder_name"
            echo "[*] Creating symlink for '$mod_folder_name' to '$junction_path'"
            ln -s "$dir" "$junction_path"
        fi
    done

    # NOTE: Dependencies directory support needs further research and testing
    # Currently creates symlinks for mod dependencies if they exist
    for dir in "$PROJECT_DIR/pkgs/$mod_name/Dependencies/"*; do
        if [ -d "$dir" ]; then
            mod_folder_name=$(basename "$dir")
            junction_path="$drive_path/$mod_folder_name"
            echo "[*] Creating symlink for dependency '$mod_folder_name' to '$junction_path'"
            ln -s "$dir" "$junction_path"
        fi
    done

    echo "[+] Workdrive setup complete!"
    echo "[*] Symlinks created at: $drive_path"
}

build_mod() {
    local mod_name=$1

    if [ -z "$mod_name" ]; then
        echo "[!] Usage: $0 build MOD_NAME"
        echo "[!] Example: $0 build mymod"
        exit 1
    fi

    local mod_dir="$PROJECT_DIR/pkgs/$mod_name"

    if [ ! -d "$mod_dir" ]; then
        echo "[!] Error: Mod not found at $mod_dir"
        exit 1
    fi

    check_docker

    local version=$(calculate_mod_version "$mod_dir")
    local pbo_filename="${mod_name}-${version}.pbo"
    local build_dir="$PROJECT_DIR/build/@$mod_name"
    mkdir -p "$build_dir/addons" "$build_dir/keys"

    echo "[*] Building mod: $mod_name"
    echo "[*] Version: $version"
    echo "[*] Source: $mod_dir"
    echo "[*] Output: $build_dir"
    echo ""

    docker_pull_image jerryhopper/depbo-tools:latest || return 1

    echo "[*] Creating PBO from source..."
    docker_depbo_tools makepbo -@="$mod_name" "$mod_dir" "$build_dir/addons/$pbo_filename" || {
        echo "[!] Failed to create PBO"
        return 1
    }

    echo "[*] Generating version metadata..."
    generate_version_metadata "$version" "$build_dir"

    echo "[*] Ensuring mod.cpp..."
    ensure_mod_cpp "$mod_dir" "$mod_name" "$version" "$build_dir"

    if find "$mod_dir" -name "*.bikey" -o -name "*.biprivatekey" | grep -q .; then
        echo "[*] Copying signing keys..."
        find "$mod_dir" -name "*.bikey" -exec cp {} "$build_dir/keys/" \; 2>/dev/null || true
        find "$mod_dir" -name "*.biprivatekey" -exec cp {} "$build_dir/keys/" \; 2>/dev/null || true
    fi

    echo "[*] Creating symlink in mods directory..."
    if create_mod_symlink "$mod_name" "$build_dir" "$PROJECT_DIR/mods"; then
        echo "[+] Symlink created: mods/@${mod_name}/"
    fi

    echo ""
    echo "[+] Build complete!"
    echo ""
    echo "Module Information:"
    echo "  Name:       $mod_name"
    echo "  Version:    $version"
    echo "  Commit:     $(get_git_commit_hash "$mod_dir")"
    echo "  Build Time: $(get_build_timestamp)"
    echo ""
    echo "Output Files:"
    ls -lh "$build_dir/addons/"
    echo ""
    echo "Ready for server:"
    echo "  mods/@${mod_name}/"
}

launch_workbench() {
       local mod_name=$1

       if [ -z "$mod_name" ]; then
           echo "[!] Usage: $0 workbench MOD_NAME"
           echo "[!] Example: $0 workbench mymod"
           exit 1
       fi

       local mod_dir="$PROJECT_DIR/pkgs/$mod_name"

       if [ ! -d "$mod_dir" ]; then
           echo "[!] Error: Mod not found at $mod_dir"
           exit 1
       fi

       if ! get_steamcmd; then
           echo "[!] SteamCMD not found"
           return 1
       fi

       echo "========================================"
       echo "⚠ WARNING: Workbench Launch (Experimental)"
       echo "========================================"
       echo ""
       echo "This command is highly experimental and may not work as expected."
       echo "It requires Steam to be installed and your account to have DayZ Tools access."
       echo ""

       local dayz_tools_appid="1559212036"
       local profiles_dir="$PROJECT_DIR/profiles"
       mkdir -p "$profiles_dir"

       echo "[*] Launching Workbench for mod: $mod_name"
       echo "[*] If this fails, try launching DayZ Tools manually from Steam"
       echo ""

       "$STEAMCMD_CMD" +@NoPromptForPassword 1 +app_run "$dayz_tools_appid" -doLogs -profiles="$profiles_dir" -repository="$mod_dir" +quit
   }

client_check() {
    check_jq

    check_config_exists || return 0

    echo "========================================"
    echo "Client Mod Status Check"
    echo "========================================"
    echo ""

    local STEAM_WORKSHOP_DIR=".steam/steam/steamapps/workshop/content/$WORKSHOP_ID"
    local steam_workshop="$HOME/$STEAM_WORKSHOP_DIR"

    echo "Checking mods in Steam Workshop directory:"
    echo "  ~/$STEAM_WORKSHOP_DIR"
    echo ""

    jq -r '.mods[] | "\(.name)[\(.id)]"' "$CONFIG_FILE" | while read mod_info; do
        local mod_id=$(echo "$mod_info" | grep -oP '\[\K[0-9]+(?=\])')
        local mod_path="$steam_workshop/$mod_id"

        if [ -d "$mod_path" ]; then
            local file_count=$(find "$mod_path" -type f | wc -l)
            echo "$mod_info ✓ - $file_count"
        else
            echo "$mod_info ✗ - 0"
        fi
    done

     echo ""
}

remove_mod() {
    local mod_identifier=$1

    if [ -z "$mod_identifier" ]; then
        echo "[!] Usage: $0 remove MOD_NAME_OR_ID"
        echo "[!] Example: $0 remove @cf"
        echo "[!] Example: $0 remove 1559212036"
        exit 1
    fi

    check_config_exists || return 0

    # Normalize mod name (add @ if not present)
    local mod_name="$mod_identifier"
    if [[ ! "$mod_name" =~ ^@ ]]; then
        mod_name="@$mod_name"
    fi

    # Try to find mod by name or ID
    local mod_id=""
    local mod_path="$PROJECT_DIR/mods/$mod_name"

    # Check if it's an ID instead of a name
    if [[ "$mod_identifier" =~ ^[0-9]+$ ]]; then
        # It's an ID - find the name
        mod_name=$(jq -r ".mods[] | select(.id == $mod_identifier) | .name" "$CONFIG_FILE")
        if [ -z "$mod_name" ] || [ "$mod_name" = "null" ]; then
            echo "[!] Error: Mod with ID $mod_identifier not found in config"
            return 1
        fi
        mod_path="$PROJECT_DIR/mods/$mod_name"
        mod_id="$mod_identifier"
    else
        # It's a name - find the ID
        mod_id=$(jq -r ".mods[] | select(.name == \"$mod_name\") | .id" "$CONFIG_FILE")
        if [ -z "$mod_id" ] || [ "$mod_id" = "null" ]; then
            echo "[!] Error: Mod $mod_name not found in config"
            return 1
        fi
    fi

    echo "========================================"
    echo "Removing Mod"
    echo "========================================"
    echo ""
    echo "Mod Name: $mod_name"
    echo "Mod ID: $mod_id"
    echo "Mod Path: $mod_path"
    echo ""

    read -p "Continue with removal? (y/n) " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        echo "[*] Removal cancelled"
        return 0
    fi

    # Remove from mods.json
    echo "[*] Removing from mods.json..."
    local temp_file=$(mktemp)
    jq ".mods |= map(select(.name != \"$mod_name\"))" "$CONFIG_FILE" > "$temp_file"
    mv "$temp_file" "$CONFIG_FILE"
    echo "[+] Removed from mods.json"

    # Remove from serverDZ.cfg
    echo "[*] Removing from serverDZ.cfg..."
    sed -i "/mods\/$mod_name\"/d" "$PROJECT_DIR/config/serverDZ.cfg"
    sed -i '/,$/N;s/,\n\s*,/,/g' "$PROJECT_DIR/config/serverDZ.cfg"  # Clean up trailing commas
    echo "[+] Removed from serverDZ.cfg"

    # Handle mod directory removal
    if [ -d "$mod_path" ]; then
        echo "[*] Handling mod directory..."
        
        # Check if it's a symlink
        if [ -L "$mod_path" ]; then
            echo "[*] Mod is symlinked (keeping pkgs/ intact)"
            rm "$mod_path"
            echo "[+] Symlink removed"
        else
            # It's a real directory
            echo "[*] Mod is a real directory"
            rm -rf "$mod_path"
            echo "[+] Directory removed"
        fi
    else
        echo "[*] Mod directory not found at $mod_path"
    fi

    echo ""
    echo "========================================"
    echo "[+] Removal Complete"
    echo "========================================"
    echo ""
}

main() {
     if [ $# -eq 0 ]; then
         print_usage
         exit 0
     fi

       case "$1" in
           new)
               new_mod "$2"
               ;;
           build)
               build_mod "$2"
               ;;
           workbench)
               launch_workbench "$2"
               ;;
            status)
                status_mods
                ;;
            client-check)
                client_check
                ;;
            search)
                search_mods "${@:2}"
                ;;
            enable)
                enable_mod "$2" "$3"
                ;;
             disable)
                 disable_mod "$2"
                 ;;
             remove)
                 remove_mod "$2"
                 ;;
            install)
               install_mods
               ;;
           update)
               update_mods
               ;;
           help|--help|-h)
               print_usage
               ;;
           *)
               echo "[!] Unknown command: $1"
               print_usage
               exit 1
               ;;
       esac
}

main "$@"
