#!/usr/bin/env bash
# vim: set filetype=bash:

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_DIR="$(dirname "$SCRIPT_DIR")"

source "$SCRIPT_DIR/_lib"

SERVER_DIR="$PROJECT_DIR/server"
LOG_DIR="$PROJECT_DIR/logs"
BACKUP_DIR="$PROJECT_DIR/backups"

mkdir -p "$LOG_DIR" "$BACKUP_DIR"

# Configuration
CONFIG_FILE="$SERVER_DIR/serverDZ.cfg"
LOG_FILE="$LOG_DIR/server.log"
PID_FILE="$LOG_DIR/server.pid"
STATUS_FILE="$LOG_DIR/server-status.txt"

# Server parameters
PORT=${PORT:-2302}
CPU_CORES=${CPU_CORES:-$(nproc)}

TEMPLATE_USAGE="""
DayZ Server Manager

Usage: $0 <command> [BUNDLE] [OPTIONS]

Commands:
    start [BUNDLE]    - Start the server (background, optional bundle)
    start [BUNDLE] --debug  - Start the server (foreground, debug mode)
    stop              - Stop the server gracefully
    status            - Check if server is running
    update            - Update server files via SteamCMD
    query             - Query local server info and status
    help              - Show this help message

Environment Variables:
    PORT              - Server port (default: 2302)
    CPU_CORES         - Number of CPU cores to use (default: auto-detect)

Examples:
    $0 start                 - Start with default bundle
    $0 start base_expansion  - Start with specific bundle
    $0 start --debug         - Start in debug mode with default bundle
    $0 start ai_expansion --debug  - Start specific bundle in debug mode
    $0 stop
    $0 status
    $0 query
"""

print_usage() {
    echo "$TEMPLATE_USAGE"
}

check_server_exists() {
    if [ ! -f "$SERVER_DIR/DayZServer" ]; then
        echo "[!] Error: DayZ Server executable not found at $SERVER_DIR/DayZServer"
        echo "[!] Please run: make install"
        return 1
    fi

    if [ ! -f "$CONFIG_FILE" ]; then
        echo "[!] Error: Server config not found at $CONFIG_FILE"
        return 1
    fi

    return 0
}

# replace "modDirs[] = {};" with the list of server mods from the bundle
sync_config() {

    local bundle
    local config_file
    local server_mods
    local client_mods

    # use jq to join both server and client mods for modDirs[]
    bundle="$1"
    config_file="$2"
    server_mods=$(get_bundle_mods "$bundle" "server" || "")
    client_mods=$(get_bundle_mods "$bundle" "client" || "")
    
    joined_mods=$(printf "%s\n%s" "$server_mods" "$client_mods" | sort -u)
    echo "[*] Mods in bundle '$bundle':"
    print_mods_list "$joined_mods"

    # Build modDirs[] string
    local mod_dirs_str="modDirs[] = {"
    local first=true
    while read -r mod; do
        if [ -n "$mod" ]; then
            if [ "$first" = true ]; then
                first=false
            else
                mod_dirs_str+=", "
            fi
            mod_dirs_str+="\"$mod\""
        fi
    done <<<"$joined_mods"
    mod_dirs_str+="};"
    echo "[*] Syncing serverDZ.cfg with mods from bundle '$bundle' to $config_file"

    # Update serverDZ.cfg
    cat ./config/serverDZ.cfg | \
        sed -E "s|^modDirs\[\] = \{.*\};|$mod_dirs_str|g" >"$config_file"

    echo "[+] serverDZ.cfg updated with mods from bundle '$bundle'"
}

announce_server() {
    local hostname=$(grep "^hostname" "$CONFIG_FILE" | cut -d'"' -f2)
    echo "Server: $hostname (port $PORT)" >"$STATUS_FILE"
    echo "If on local network, try: ${hostname// /_}.local:$PORT" >>"$STATUS_FILE"
}

cmd_query() {
    if [ ! -f "$CONFIG_FILE" ]; then
        echo "[!] Server config not found at $CONFIG_FILE"
        return 1
    fi

    echo "========================================"
    echo "DayZ Server Query"
    echo "========================================"
    echo ""

    local hostname=$(grep "^hostname" "$CONFIG_FILE" | cut -d'"' -f2)
    local port=$(grep "^port" "$CONFIG_FILE" | cut -d' ' -f3 | tr -d ';')
    local max_players=$(grep "^maxPlayers =" "$CONFIG_FILE" | grep -v Steam | cut -d' ' -f3 | tr -d ';')
    local difficulty=$(grep "^difficulty" "$CONFIG_FILE" | cut -d'"' -f2)

    echo "Hostname:    $hostname"
    echo "Port:        ${port:-2302}"
    echo "Max Players: ${max_players:-60}"
    echo "Difficulty:  ${difficulty:-hard}"
    echo ""

    if cmd_status >/dev/null 2>&1; then
        echo "Status:      [ONLINE]"
        local server_pid=$(cat "$PID_FILE" 2>/dev/null)

        if [ -n "$server_pid" ]; then
            local uptime=$(ps -p "$server_pid" -o etime= 2>/dev/null | tr -d ' ' || echo "unknown")
            echo "Uptime:      $uptime"

            local memory=$(ps -p "$server_pid" -o rss= 2>/dev/null | awk '{printf "%.0f MB", $1/1024}' || echo "unknown")
            echo "Memory:      $memory"

            local cpu=$(ps -p "$server_pid" -o %cpu= 2>/dev/null | tr -d ' ' || echo "unknown")
            echo "CPU Usage:   ${cpu}%"
        fi
    else
        echo "Status:      [OFFLINE]"
    fi

    echo ""

    local mod_count=$([ -f "$PROJECT_DIR/config/mods.json" ] && jq '.mods | length' "$PROJECT_DIR/config/mods.json" 2>/dev/null || echo "0")
    echo "Configured Mods: $mod_count"

    local latest_log="$LOG_DIR/server_latest.log"
     if [ -f "$latest_log" ]; then
         local log_lines=$(wc -l <"$latest_log")
         echo "Log entries: $log_lines lines"
     elif [ -f "$LOG_FILE" ]; then
         # Fallback for old static log file
         local log_lines=$(wc -l <"$LOG_FILE")
         echo "Log entries: $log_lines lines"
     fi

    echo ""
}

cmd_status() {
    if [ ! -f "$PID_FILE" ]; then
        echo "[*] Server is not running (no PID file)"
        return 1
    fi

    SERVER_PID=$(cat "$PID_FILE")

    if kill -0 "$SERVER_PID" 2>/dev/null; then
        echo "[+] Server is running (PID: $SERVER_PID)"
        return 0
    else
        echo "[!] Server is not running (PID file exists but process not found)"
        return 1
    fi
}

get_bundle_mods() {
    local bundle_name
    local mod_type

    bundle_name="$1"
    mod_type="$2"  # "server" or "client"

    mods=$(
        jq -r \
            --arg bundle "$bundle_name" \
            --arg type "$mod_type" \
            '.bundles[$bundle][$type] // [] | .[]' \
            "$PROJECT_DIR/config/mods.json"
    )

    if [ $? -ne 0 ]; then
        echo "[!] Error retrieving mods for bundle '$bundle_name' and type '$mod_type'"
        exit 1
    fi

    echo "$mods"
}

assert_bundle_mods () {
    local mods
    mods="$1"

    if [ -z "$mods" ]; then
        echo "[!] No mods found in the specified bundle"
        return 1
    fi

    return 0
}

print_mods_list() {
    local mods
    mods="$1"

    echo "$mods" | while read -r mod; do
        echo "  - $mod"
    done
}

join_mod_for_arg() {
    local mods
    mods="$1"

    local joined_mods=""
    while read -r mod; do
        if [ -n "$mod" ]; then
            if [ -z "$joined_mods" ]; then
                joined_mods="../mods/$mod"
            else
                joined_mods+=";../mods/${mod}"
            fi
        fi
    done <<<"$mods"

    echo "$joined_mods"
}

cmd_start() {
    declare -A args=(
        [port]="$PORT"
        [config]="serverDZ.cfg"
        [cpuCount]="$CPU_CORES"
    )
    local debug_mode=false
    local bundle_name="base_expansion"

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
        --debug)
            # Enable debug mode (foreground, verbose logging)
            debug_mode=true
            shift
            ;;
        *)
            # First non-flag argument is treated as the bundle name
            # This allows specifying a different mod configuration bundle
            # Bundles are defined in config/mods.json
            if [[ -z "${args[bundle]:-}" ]]; then
                bundle_name="$1"
                shift
            else
                echo "[!] Unknown option: $1"
                return 1
            fi
            ;;
        esac
    done

    # Validate bundle
    if ! jq -e --arg bundle "$bundle_name" '.bundles[$bundle]' "$PROJECT_DIR/config/mods.json" >/dev/null; then
        echo "[!] Bundle '$bundle_name' not found"
        return 1
    fi

    if [ -f "$PID_FILE" ]; then
        OLD_PID=$(cat "$PID_FILE")
        if kill -0 "$OLD_PID" 2>/dev/null; then
            echo "[*] Stopping existing server (PID: $OLD_PID)"
            kill "$OLD_PID" || true
            sleep 5
        fi
        rm -f "$PID_FILE"
    fi

    declare -A mods=()

    # Build mod list from bundle in mods.json (server mods only)
    args[servermod]=""
    local server_mod_list=$(get_bundle_mods "$bundle_name" "server")
    assert_bundle_mods "$server_mod_list" && {
        local server_mod_count=$(echo "$server_mod_list" | wc -l)
        echo "[*] Loading $server_mod_count server mod(s) from bundle '$bundle_name'"
        args[servermod]="$server_mod_list"
    }

    args[clientmod]=""
    local client_mod_list=$(get_bundle_mods "$bundle_name" "client")
    assert_bundle_mods "$client_mod_list" && {
        local client_mod_count=$(echo "$client_mod_list" | wc -l)
        echo "[*] Note: Bundle '$bundle_name' includes $client_mod_count client mod(s) for Steam Workshop"
        args[clientmod]="$client_mod_list"
    }

    sync_config "$bundle_name" "./server/serverDZ.cfg"
    check_server_exists || return 1
    announce_server

    echo "========================================"
    echo "DayZ Server Startup"
    echo "========================================"
    echo ""
    echo "Configuration:"
    echo "  Port: ${args[port]}"
    echo "  Config: ${args[config]}"
    echo "  Log: $LOG_FILE"
    echo "  CPU Cores: ${args[cpuCount]}"
    echo "  Mode: $([ "$debug_mode" = true ] && echo "DEBUG (foreground)" || echo "Normal (background)")"
    echo ""

    # Print mods from bundle
    echo "Bundle: $bundle_name"
    
    [ -n "$server_mod_list" ] && {
        echo "  Server Mods:"
        print_mods_list "$server_mod_list"
    }

    [ -n "$client_mod_list" ] && {
        echo "  Client Mods:"
        print_mods_list "$client_mod_list"
    }
    
    echo ""

    echo "[*] Starting DayZ Server..."

    cd "$SERVER_DIR"
    echo "" >"$LOG_FILE"

    # Show connection info
    local hostname=$(grep "^hostname" "$CONFIG_FILE" | cut -d'"' -f2)
    echo ""
    echo "Connection Info:"
    echo "  Server: $hostname"
    echo "  Address: $(get_ip):${args[port]}"
    echo ""

    # Build and display command
     echo "[*] Command:"
     echo "  ./DayZServer"
     echo "     -filepatching"
     echo "     -port=${args[port]}"
     echo "     -config=${args[config]}"
     echo "     -cpuCount=${args[cpuCount]}"
     server_mod_arg=$(join_mod_for_arg "${args[servermod]}")
     client_mod_arg=$(join_mod_for_arg "${args[clientmod]}")
     [ -n "${args[servermod]:-}" ] && echo "     --serverMod=${server_mod_arg}"
     [ -n "${args[clientmod]:-}" ] && echo "     --mod=${client_mod_arg}"
     printf "\n"

     # Prepare exec args array
      local -a exec_args=()
      exec_args+=("-filepatching=1")
      exec_args+=("-port=${args[port]}")
      exec_args+=("-config=${args[config]}")
      exec_args+=("-cpuCount=${args[cpuCount]}")
      [ -n "${args[servermod]:-}" ] && exec_args+=("--serverMod=${server_mod_arg}")
      [ -n "${args[clientmod]:-}" ] && exec_args+=("--clientMod=${client_mod_arg}")

     # Generate timestamped log filename
      local timestamp=$(date '+%Y%m%d_%H%M%S')
      local timestamped_log="$LOG_DIR/server_${timestamp}.log"
      local latest_log="$LOG_DIR/server_latest.log"

     # Execute server
     if [ "$debug_mode" = true ]; then
        echo "[*] Running in DEBUG mode (foreground)..."
        echo "[*] Logging to: $timestamped_log"
        echo "[*] Press Ctrl+C to stop the server"
        echo ""

        ./DayZServer "${exec_args[@]}" 2>&1 | tee -a "$timestamped_log"
        local exit_code=${PIPESTATUS[0]}

        echo ""
        echo "[*] Server stopped with exit code: $exit_code"
        rm -f "$PID_FILE"
        
        # Create symlink to latest log
        ln -sf "server_${timestamp}.log" "$latest_log" 2>/dev/null || true
        return $exit_code
     else
        echo "[*] Running in normal mode (background)..."
        echo ""

        ./DayZServer "${exec_args[@]}" >>"$timestamped_log" 2>&1 &
        local server_pid=$!
        echo $server_pid >"$PID_FILE"

        echo "[+] Server started (PID: $server_pid)"
        echo "[+] Log file: $timestamped_log"
        echo "[+] Latest log: $latest_log"
        echo ""
        echo "To monitor the server:"
        echo "  make logs-tail"
        echo ""
        echo "To stop the server:"
        echo "  make stop"
        echo ""

        sleep 2

        if kill -0 $server_pid 2>/dev/null; then
            echo "[+] Server is running successfully"
            return 0
        else
            echo "[!] Server failed to start. Check logs:"
            tail -20 "$LOG_FILE"
            return 1
        fi
    fi
}

cmd_stop() {
    if [ ! -f "$PID_FILE" ]; then
        echo "[!] Server PID file not found. Server may not be running."
        return 1
    fi

    local server_pid=$(cat "$PID_FILE")

    if ! kill -0 "$server_pid" 2>/dev/null; then
        echo "[!] Server with PID $server_pid is not running"
        rm -f "$PID_FILE"
        return 1
    fi

    echo "========================================"
    echo "DayZ Server Shutdown"
    echo "========================================"
    echo ""
    echo "[*] Stopping server (PID: $server_pid)..."
    echo "[*] Waiting for graceful shutdown (30 seconds)..."

    kill -SIGTERM "$server_pid" || true

    local timeout=30
    while [ $timeout -gt 0 ]; do
        if ! kill -0 "$server_pid" 2>/dev/null; then
            echo "[+] Server stopped gracefully"
            break
        fi

        echo -n "."
        sleep 1
        ((timeout--))
    done

    echo ""

    if kill -0 "$server_pid" 2>/dev/null; then
        echo "[!] Server did not stop gracefully. Force killing..."
        kill -SIGKILL "$server_pid" || true
        sleep 2
    fi

    if ! kill -0 "$server_pid" 2>/dev/null; then
        echo "[+] Server stopped"
        rm -f "$PID_FILE" "$STATUS_FILE"
    else
        echo "[!] Failed to stop server"
        return 1
    fi

    echo ""
    echo "========================================"
    echo "Server stopped successfully"
    echo "========================================"
    return 0
}

cmd_update() {
    check_server_exists || return 1

    echo "========================================"
    echo "DayZ Server Update Script"
    echo "========================================"
    echo ""
    echo "This will:"
    echo "  1. Create a backup of current server"
    echo "  2. Stop the running server"
    echo "  3. Update server files via SteamCMD"
    echo "  4. Verify installation"
    echo ""

    read -p "Continue? (y/n) " -n 1 -r
    echo

    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        echo "[*] Update cancelled"
        return 0
    fi

    # Create backup
    echo "[*] Creating backup before update..."
    mkdir -p "$BACKUP_DIR"
    local timestamp=$(date +%Y%m%d_%H%M%S)
    local backup_file="$BACKUP_DIR/server_backup_$timestamp.tar.gz"
    echo "[*] Backing up to: $backup_file"

    if tar -czf "$backup_file" \
        --exclude='*.tar.gz' \
        -C "$PROJECT_DIR" server/ config/ mods/ 2>/dev/null; then
        local size=$(du -h "$backup_file" | cut -f1)
        echo "[+] Backup created: $size"
    else
        echo "[!] Backup creation may have failed"
    fi

    # Stop server
    if [ -f "$PID_FILE" ]; then
        echo "[*] Stopping server before update..."
        cmd_stop || true
        sleep 5
    fi

    # Update server files
    echo "[*] Updating server files..."
    echo ""
    echo "Checking for DayZ server updates via SteamCMD..."

    # Check for SteamCMD
    local steamcmd_cmd=""
    if command -v steamcmd &>/dev/null; then
        steamcmd_cmd="steamcmd"
    elif [ -f "$HOME/.local/share/steamcmd/steamcmd.sh" ]; then
        steamcmd_cmd="$HOME/.local/share/steamcmd/steamcmd.sh"
    elif [ -f "$HOME/.steam/steamcmd/steamcmd.sh" ]; then
        steamcmd_cmd="$HOME/.steam/steamcmd/steamcmd.sh"
    else
        echo "[!] SteamCMD not found. Cannot update."
        return 1
    fi

    read -p "Enter Steam username: " steam_user
    read -sp "Enter Steam password: " steam_pass
    echo ""

    if ! "$steamcmd_cmd" \
        +@NoPromptForPassword 1 \
        +login "$steam_user" "$steam_pass" \
        +force_install_dir "$SERVER_DIR" \
        +app_update 223350 validate \
        +quit; then

        echo "[!] Update failed"
        return 1
    fi

    echo "[+] Server files updated"

    # Verify installation
    echo "[*] Verifying installation..."
    if [ ! -f "$SERVER_DIR/DayZServer" ]; then
        echo "[!] DayZServer executable not found"
        return 1
    fi
    echo "[+] Installation verified"

    echo ""
    echo "========================================"
    echo "Update Complete!"
    echo "========================================"
    echo ""
    echo "To restart the server:"
    echo "  make restart"
    echo ""
    echo "Backups are saved in: $BACKUP_DIR"
    echo ""
}

main() {
    if [ $# -eq 0 ]; then
        print_usage
        return 0
    fi

    case "$1" in
    start)
        shift
        cmd_start "$@"
        ;;
    stop)
        cmd_stop
        ;;
    update)
        cmd_update
        ;;
    status)
        cmd_status
        ;;
    query)
        cmd_query
        ;;
    help)
        print_usage
        ;;
    *)
        echo "[!] Unknown command: $1"
        print_usage
        return 1
        ;;
    esac
}

main "$@"
